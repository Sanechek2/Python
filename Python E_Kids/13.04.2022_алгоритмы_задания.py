
# Алгоритмы
#
# 1.  Линейный поиск (Linear Search)

# 2.  Двоичный поиск (Binary Search)
# 3.  Двоичные деревья (Binary Trees)
# 
# 4.  Алгоритм поиска вглубь (DFS)
# 5.  Алгоритм поиска вширь (BFS)
# 6.  Алгоритм Хаффмана (Huffman Compression)
# 7.  Поиск подстроки (Substring Search)
# 8.  Сортировка пузырьковая (Bubble Sort)
# 9.  Сортировка выбором (Selection Sort)
# 10. Сортировка вставками (Insert Sort)
# 11. Coртировка слиянием (Merge Sort)






# 1. Линейный поиск (Linear Search)
#
# Задача: имея массив данных (например список целых чисел), найти индекс, под которым появляется
# заданный элемент
#
# Например: spisok = [100, 300, 700, 200]
# rezultat = linejny_poisk( spisok, 700 )
# print( rezultat )

def lin_poisk( spisok, iscomoe):
    #for number in spisok:
    for i in range (0, len(spisok)):
        number = spisok[i]
        proverka = (number == iscomoe)
        if  proverka == True:
            #print(number, 'лежит на позиции ', i, '(количество проверок)', i+1)
            return i+1
            break
            
    
spisok = [101, 111]

rezulat = lin_poisk ( spisok, 111 )

import random
summa = 0
for ne in range(1, 5000):
    spisok = []
    for i in range(1000):
        sluch = random.randint(1, 1000)
        spisok += [sluch]

    #print(spisok)

    iskomoe = random.choice(spisok)
    #print(iskomoe)

    rezultat = lin_poisk(spisok, iskomoe)
    summa += rezulat
print (summa / 5000)



# >>> 2
#
# Дополнительно: взять список из 1000 случайных целых чисел, выбрать из него одно случайное,
# затем найти линейным поиском индекс этого числа, и записать количество шагов,
# которые потребовались для поиска. 
# Повторить это 5000 раз, и посчитать среднее количество шагов, которое требуется этому алгоритму.
#








# 1. Двоичный поиск (Binary Search)
#
# Задача: имея _посортированный_ массив данных (например список целых чисел),
# найти индекс, под которым появляется заданный элемент
#
# Например: spisok = [100, 200, 300, 700] # список посортирован по возрастанию
# rezultat = dvoichny_poisk( spisok, 200 )
# print( rezultat )
# >>> 1
#
# Дополнительно: то же самое что в предыдущем задании.
# Cгенерированные случаным образом списки стоит посортировать:
# spisok.sort() либо spisok = sorted(spisok)
#
# Алгоритм:
# 1. Создай указатели на первый и на последний элемент
# 2. Найди элемент ровно между ними
# 3. Сравни искомое число с этим средним элементом
# 4. Если искомое число больше, передвинь левый указатель
# 5. Если меньше, то передвинь правый
# 6. Если равно, значит искомое число найдено (верни или выпиши на экран индекс)
# 7. Если вдруг два указателя равны, а число всё ещё не найдено,
#    значит его нет в списке











# Двоичные деревья (Binary Trees)
#
# Задание:
# Написать класс Node (то есть "Узел"), который имеет поле значения (например число),
# а так же два указателя - на левого и на правого "ребёнка".
# Cоздать двоичное дерево с узлами 1, 2, 3, 4, 5
# Выписать все узлы дерева тремя способами: прямым, обратным, и центрированным
#
#         1
#     2       3
#  4     5
#
# Прямой обход:   1 2 3 4 5
# Обратный обход: 4 5 2 3 1
# Центрированный: 4 2 5 1 3
#

















